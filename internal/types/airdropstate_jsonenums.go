// generated by jsonenums -type=AirdropState -tprefix=false -transform=snake; DO NOT EDIT
package types

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
)

func init() {
	// stubs for imports
	_ = json.Delim('s')
	_ = driver.Int32

}

var ErrAirdropStateInvalid = errors.New("AirdropState is invalid")

func init() {
	var v AirdropState
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_AirdropStateNameToValue = map[string]AirdropState{
			interface{}(AirdropStateNotEligible).(fmt.Stringer).String(): AirdropStateNotEligible,
			interface{}(AirdropStateEligible).(fmt.Stringer).String():    AirdropStateEligible,
			interface{}(AirdropStateClaimed).(fmt.Stringer).String():     AirdropStateClaimed,
		}
	}
}

var _AirdropStateNameToValue = map[string]AirdropState{
	"not_eligible": AirdropStateNotEligible,
	"eligible":     AirdropStateEligible,
	"claimed":      AirdropStateClaimed,
}

var _AirdropStateValueToName = map[AirdropState]string{
	AirdropStateNotEligible: "not_eligible",
	AirdropStateEligible:    "eligible",
	AirdropStateClaimed:     "claimed",
}

// String is generated so AirdropState satisfies fmt.Stringer.
func (r AirdropState) String() string {
	s, ok := _AirdropStateValueToName[r]
	if !ok {
		return fmt.Sprintf("AirdropState(%d)", r)
	}
	return s
}

// Validate verifies that value is predefined for AirdropState.
func (r AirdropState) Validate() error {
	_, ok := _AirdropStateValueToName[r]
	if !ok {
		return ErrAirdropStateInvalid
	}
	return nil
}

// MarshalJSON is generated so AirdropState satisfies json.Marshaler.
func (r AirdropState) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _AirdropStateValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid AirdropState: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so AirdropState satisfies json.Unmarshaler.
func (r *AirdropState) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("AirdropState should be a string, got %s", data)
	}
	v, ok := _AirdropStateNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid AirdropState %q", s)
	}
	*r = v
	return nil
}

func (t *AirdropState) Scan(src interface{}) error {
	i, ok := src.(int64)
	if !ok {
		return fmt.Errorf("can't scan from %T", src)
	}
	*t = AirdropState(i)
	return nil
}

func (t AirdropState) Value() (driver.Value, error) {
	return int64(t), nil
}
